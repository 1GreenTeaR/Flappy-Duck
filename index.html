<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>FlappyDuck</title>
        <script type="text/javascript" src="/ground.js"></script>
        <script type="text/javascript" src="/obstacle.js"></script>
        <script type="text/javascript" src="/player.js"></script>
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link href="https://fonts.googleapis.com/css2?family=Tiny5&display=swap" rel="stylesheet" />

        <style>
            html,
            body {
                margin: 0;
                padding: 0;
            }

            html {
                background-color: black;
            }

            body {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden;
            }

            #canvas {
                background-color: #70c5cd;
            }

            .dev-panel {
                position: fixed;
                top: 0;
                right: 0;
            }

            .dev-button {
                color: white;
                padding: 10px 20px;
                background-color: green;
                border-radius: 20px;
                user-select: none;
                cursor: pointer;
            }

            .game-container {
                position: relative;
            }

            .end-game-container {
                background-color: #ded895;
                padding: 6px;
                flex-direction: column;
                align-items: center;
                min-width: 120px;
                min-height: 140px;

                position: absolute;
                top: 50%;
                left: 50%;

                transform: translate(-50%, -50%);
                outline: 4px solid #543847;
                user-select: none;

                font-family: 'Tiny5', monospace;
            }

            .end-game {
                min-width: 118px;
                min-height: 138px;
                border-top: 4px solid #bfa651;
                border-left: 4px solid #bfa651;
                border-bottom: 4px solid #f3ec9e;
                border-right: 4px solid #f3ec9e;
                align-items: center;
                justify-content: center;
                display: flex;
                flex-direction: column;
                padding: 10px;
            }

            .end-game-text {
                font-size: 24px;
                color: #bfa651;
                text-shadow: 1px 1px 2px #f3ec9e;
            }

            #end-game-score,
            #end-game-best-score {
                display: block;
                position: relative;
                font-size: 46px;
                font-weight: bold;
                color: #ffffff;
                text-align: center;
                line-height: 1;
                margin: 0;
                filter: drop-shadow(-4px 0 0 #000) drop-shadow(4px 0 0 #000)
                    drop-shadow(0 -4px 0 #000) drop-shadow(0 4px 0 #000);
                /* letter-spacing: 2px; */
                padding-bottom: 8px;
            }

            #end-game-container {
                display: none;
            }

            #end-game-congrats {
                display: none;
            }

            button {
                font-family: 'Tiny5', monospace;
                border-radius: 0;
                outline: 3px solid #543847;
                border: 3px solid #fcf7e7;
                background-color: #dd5f2d;
                color: #fcf7e7;
                padding: 8px;
                font-size: 20px;
                font-weight: bold;
                transition: transform 0.1s, filter 0.1s;
                margin-top: 8px;
            }
            button:active {
                filter: brightness(0.9);
                transform: scale(0.95) translateY(2px);
            }
        </style>
    </head>

    <body>
        <div class="game-container">
            <canvas id="canvas"></canvas>
            <div id="end-game-container" class="end-game-container">
                <div class="end-game">
                    <div id="end-game-congrats">NEW HIGHSCORE!</div>
                    <div class="end-game-text">SCORE</div>
                    <div id="end-game-best-score">-</div>
                    <div class="end-game-text">BEST</div>
                    <div id="end-game-score">-</div>
                    <button onclick="start()">RESTART</button>
                </div>
            </div>
        </div>
        <!-- <div class="dev-panel">
            <div class="dev-button" tabindex="-1" onclick="start()">restart</div>
        </div> -->

        <script>
            const canvas = document.getElementById('canvas');
            const c = canvas.getContext('2d', { alpha: false });
            let bestScore = Number(localStorage.getItem('best-score') ?? 0);

            const config = {
                width: 400,
                height: 600,
                scale: 1,
                speed: 1,
                debug: false,
            };

            const state = {
                scale: undefined,
                width: undefined,
                height: undefined,
                // TODO needs better name
                updateData: {
                    ticksPerSecond: 120,
                    tickDurationMs: 1000 / 120,
                    lastUpdate: undefined,
                    ticks: 0,
                },
                levelData: {
                    isRunning: false,
                    tubes: undefined,
                    player: undefined,
                    startTick: undefined,
                },
                input: { up: false, lastUpTime: window.performance.now() },
                debug: {
                    x: 0,
                    y: 0,
                    offsetX: 0,
                    offsetY: 0,
                },
            };

            function setScale() {
                let scaleOuter = Math.min(
                    window.innerWidth / config.width,
                    window.innerHeight / config.height
                );

                state.scale = window.devicePixelRatio * scaleOuter * config.scale;

                // canvas.style.width = `${Math.floor(400 * scaleOuter)}px`;
                // canvas.style.height = `${Math.floor(600 * scaleOuter)}px`;

                canvas.style.width = `${config.width * scaleOuter}px`;
                canvas.style.height = `${config.height * scaleOuter}px`;

                state.width = config.width * state.scale;
                state.height = config.height * state.scale;

                c.canvas.width = state.width;
                c.canvas.height = state.height;

                console.log('Setting style size ', canvas.style.width, ' x ', canvas.style.height);
                console.log('Setting canvas size ', c.canvas.width, ' x ', c.canvas.height);

                const pos = canvas.getBoundingClientRect();
                state.debug.offsetX = pos.x;
                state.debug.offsetY = pos.y;
            }

            function render() {
                const gradient = c.createLinearGradient(0, 0, 0, c.canvas.height);
                gradient.addColorStop(0, '#319fd6');
                gradient.addColorStop(1, '#67b5db');
                c.fillStyle = gradient;
                c.fillRect(0, 0, c.canvas.width, c.canvas.height);
                c.fillStyle = 'red';

                if (state.levelData.isRunning) {
                    state.levelData.tubes.forEach((tube) => {
                        tube.render();
                    });

                    state.levelData.ground.render();

                    state.levelData.player.render();

                    c.font = `${48 * state.scale}px "Tiny5", monospace`;
                    c.textAlign = 'center';
                    c.textBaseline = 'middle';
                    c.fillStyle = 'white';
                    c.strokeStyle = 'black';
                    c.lineWidth = 6 * state.scale;
                    c.strokeText(state.levelData.player.points, state.width / 2, state.height / 6);
                    c.fillText(state.levelData.player.points, state.width / 2, state.height / 6);
                }
            }

            function update() {
                if (state.updateData.lastUpdate === undefined)
                    state.updateData.lastUpdate = window.performance.now();
                const delta = window.performance.now() - state.updateData.lastUpdate;
                const updatesAmount = Math.floor(delta / state.updateData.tickDurationMs);
                state.updateData.lastUpdate += state.updateData.tickDurationMs * updatesAmount;

                for (let i = 0; i < updatesAmount; i++) {
                    if (state.levelData.isRunning) {
                        state.levelData.tubes.forEach((tube) => {
                            tube.update();
                        });
                        state.levelData.player.update();
                        state.levelData.ground.update();

                        if (config.debug) {
                            state.levelData.player.velocity = 0;
                            state.levelData.player.x =
                                (state.debug.x - state.debug.offsetX) / state.width;
                            state.levelData.player.y =
                                (state.debug.y - state.debug.offsetY) / state.height;
                        }

                        // if (state.input.down === true) state.player.y = state.player.y + 1;

                        if (
                            (state.updateData.ticks - state.levelData.startTick) %
                                (state.updateData.ticksPerSecond * (4 / config.speed)) <
                                1 &&
                            state.levelData.player.isAlive === true
                        ) {
                            state.levelData.tubes.push(
                                new Obstacle(1 + OBSTICLE_SIZE / config.width / 2, Math.random())
                            );
                        }
                    }

                    state.updateData.ticks++;
                }
            }

            function end() {
                const endGameContainerElement = document.getElementById('end-game-container');
                const endGameScore = document.getElementById('end-game-score');
                const endGameBestScore = document.getElementById('end-game-best-score');
                const endGameCongrats = document.getElementById('end-game-congrats');
                endGameContainerElement.style.display = 'flex';
                endGameScore.innerHTML = state.levelData.player.points;

                if (bestScore < state.levelData.player.points) {
                    bestScore = state.levelData.player.points;
                    localStorage.setItem('best-score', bestScore);
                    endGameCongrats.style.display = 'flex';
                } else endGameCongrats.style.display = 'none';
                endGameBestScore.innerHTML = bestScore;
            }

            function start() {
                // levelData: {
                //     tubes: [],
                //     player: new Player(),
                // },
                const endGameContainerElement = document.getElementById('end-game-container');
                endGameContainerElement.style.display = 'none';

                state.levelData = {
                    isRunning: true,
                    tubes: [],
                    player: new Player(),
                    startTick: state.updateData.ticks,
                    ground: new Ground(),
                };

                console.log('start');
            }

            function run() {
                start();
                const cycle = () => {
                    update();
                    render();
                    window.requestAnimationFrame(cycle);
                };
                cycle();
            }

            setScale();
            run();

            window.addEventListener('resize', () => {
                setScale();
                render();
            });

            if (config.debug) {
                canvas.addEventListener('mousemove', (e) => {
                    state.debug.x = e.clientX;
                    state.debug.y = e.clientY;
                });
            }

            window.addEventListener('keydown', (e) => {
                if (e.repeat) return;
                if (e.code === 'Space' && window.performance.now() > state.input.lastUpTime + 5) {
                    state.input.lastUpTime = window.performance.now();
                    state.input.up = true;
                }
            });

            window.addEventListener('keyup', (e) => {
                if (e.repeat) return;
                if (e.code === 'Space') {
                    state.input.up = false;
                }
            });

            window.addEventListener('mousedown', (e) => {
                state.input.up = true;
            });
        </script>
    </body>
</html>

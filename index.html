<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>FlappyDuck</title>
        <script type="text/javascript" src="/obstacle.js"></script>
        <script type="text/javascript" src="/player.js"></script>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
            }

            html {
                background-color: black;
            }

            body {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden;
            }

            #canvas {
                background-color: #70c5cd;
            }
        </style>
    </head>

    <body>
        <canvas id="canvas"></canvas>
        <script>
            const canvas = document.getElementById('canvas');
            const c = canvas.getContext('2d');

            const config = {
                width: 400,
                height: 600,
                scale: 1,
                debug: false,
            };

            const state = {
                scale: undefined,
                width: undefined,
                height: undefined,
                // TODO needs better name
                updateData: {
                    ticksPerSecond: 120,
                    tickDurationMs: 1000 / 120,
                    lastUpdate: undefined,
                    ticks: 0,
                },
                input: { up: false, lastUpTime: window.performance.now() },
                debug: {
                    x: 0,
                    y: 0,
                    offsetX: 0,
                    offsetY: 0,
                },
            };

            const tubes = [];
            const player = new Player();

            function setScale() {
                let scaleOuter = Math.min(
                    window.innerWidth / config.width,
                    window.innerHeight / config.height
                );

                state.scale = window.devicePixelRatio * scaleOuter * config.scale;

                // canvas.style.width = `${Math.floor(400 * scaleOuter)}px`;
                // canvas.style.height = `${Math.floor(600 * scaleOuter)}px`;

                canvas.style.width = `${config.width * scaleOuter}px`;
                canvas.style.height = `${config.height * scaleOuter}px`;

                state.width = config.width * state.scale;
                state.height = config.height * state.scale;

                c.canvas.width = state.width;
                c.canvas.height = state.height;

                console.log('Setting style size ', canvas.style.width, ' x ', canvas.style.height);
                console.log('Setting canvas size ', c.canvas.width, ' x ', c.canvas.height);

                const pos = canvas.getBoundingClientRect();
                state.debug.offsetX = pos.x;
                state.debug.offsetY = pos.y;
            }

            function render() {
                c.fillStyle = 'blue';
                c.clearRect(0, 0, c.canvas.width, c.canvas.height);
                c.fillStyle = 'red';

                tubes.forEach((tube) => {
                    tube.render();
                });
                player.render();

                c.fillText('Points: ' + player.points, 10, 10);
            }

            function update() {
                if (state.updateData.lastUpdate === undefined)
                    state.updateData.lastUpdate = window.performance.now();
                const delta = window.performance.now() - state.updateData.lastUpdate;
                const updatesAmount = Math.floor(delta / state.updateData.tickDurationMs);
                state.updateData.lastUpdate += state.updateData.tickDurationMs * updatesAmount;

                for (let i = 0; i < updatesAmount; i++) {
                    tubes.forEach((tube) => {
                        tube.update();
                    });
                    player.update();
                    if (config.debug) {
                        player.velocity = 0;
                        player.x = (state.debug.x - state.debug.offsetX) / state.width;
                        player.y = (state.debug.y - state.debug.offsetY) / state.height;
                    }

                    // if (state.input.down === true) state.player.y = state.player.y + 1;

                    if (state.updateData.ticks % (state.updateData.ticksPerSecond * 4) === 0) {
                        tubes.push(new Obstacle(1 + 50 / config.width / 2, Math.random()));
                    }

                    state.updateData.ticks++;
                }
            }

            function start() {
                update();
                render();
                window.requestAnimationFrame(start);
            }

            setScale();
            start();

            window.addEventListener('resize', () => {
                setScale();
                render();
            });

            if (config.debug) {
                canvas.addEventListener('mousemove', (e) => {
                    state.debug.x = e.clientX;
                    state.debug.y = e.clientY;
                    console.log(e);
                });
            }

            window.addEventListener('keydown', (e) => {
                console.log(e);
                if (e.repeat) return;
                if (e.code === 'Space' && window.performance.now() > state.input.lastUpTime + 5) {
                    state.input.lastUpTime = window.performance.now();
                    state.input.up = true;
                }
            });

            // window.addEventListener("keyup", (e) => {
            //   console.log(e);
            //   if (e.repeat) return;
            //   if (e.code === "Space") {
            //     state.input.up = false;
            //     state.input.jumped = false;
            //   }
            // });
        </script>
    </body>
</html>

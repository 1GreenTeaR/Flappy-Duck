<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>FlappyDuck</title>
        <script type="text/javascript" src="/obstacle.js"></script>
        <script type="text/javascript" src="/player.js"></script>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
            }

            html {
                background-color: black;
            }

            body {
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden;
            }

            #canvas {
                background-color: #70c5cd;
            }

            .dev-panel {
                position: fixed;
                top: 0;
                right: 0;
            }

            .dev-button {
                color: white;
                padding: 10px 20px;
                background-color: green;
                border-radius: 20px;
                user-select: none;
                cursor: pointer;
            }

            .game-container {
                position: relative;
            }

            .end-game-container {
                background-color: gray;
                padding: 20px;
                border-radius: 20px;

                position: absolute;
                top: 50%;
                left: 50%;

                transform: translate(-50%, -50%);
            }
        </style>
    </head>

    <body>
        <div class="game-container">
            <canvas id="canvas"></canvas>
            <div class="end-game-container">test</div>
        </div>
        <div class="dev-panel">
            <div class="dev-button" tabindex="-1" onclick="start()">restart</div>
        </div>

        <script>
            const canvas = document.getElementById('canvas');
            const c = canvas.getContext('2d');

            const config = {
                width: 400,
                height: 600,
                scale: 1,
                debug: false,
            };

            const state = {
                scale: undefined,
                width: undefined,
                height: undefined,
                // TODO needs better name
                updateData: {
                    ticksPerSecond: 120,
                    tickDurationMs: 1000 / 120,
                    lastUpdate: undefined,
                    ticks: 0,
                },
                levelData: {
                    isRunning: false,
                    tubes: undefined,
                    player: undefined,
                    startTick: undefined,
                },
                input: { up: false, lastUpTime: window.performance.now() },
                debug: {
                    x: 0,
                    y: 0,
                    offsetX: 0,
                    offsetY: 0,
                },
            };

            function setScale() {
                let scaleOuter = Math.min(
                    window.innerWidth / config.width,
                    window.innerHeight / config.height
                );

                state.scale = window.devicePixelRatio * scaleOuter * config.scale;

                // canvas.style.width = `${Math.floor(400 * scaleOuter)}px`;
                // canvas.style.height = `${Math.floor(600 * scaleOuter)}px`;

                canvas.style.width = `${config.width * scaleOuter}px`;
                canvas.style.height = `${config.height * scaleOuter}px`;

                state.width = config.width * state.scale;
                state.height = config.height * state.scale;

                c.canvas.width = state.width;
                c.canvas.height = state.height;

                console.log('Setting style size ', canvas.style.width, ' x ', canvas.style.height);
                console.log('Setting canvas size ', c.canvas.width, ' x ', c.canvas.height);

                const pos = canvas.getBoundingClientRect();
                state.debug.offsetX = pos.x;
                state.debug.offsetY = pos.y;
            }

            function render() {
                c.fillStyle = 'blue';
                c.clearRect(0, 0, c.canvas.width, c.canvas.height);
                c.fillStyle = 'red';

                if (state.levelData.isRunning) {
                    state.levelData.tubes.forEach((tube) => {
                        tube.render();
                    });
                    state.levelData.player.render();

                    c.fillText('Points: ' + state.levelData.player.points, 10, 10);
                }
            }

            function update() {
                if (state.updateData.lastUpdate === undefined)
                    state.updateData.lastUpdate = window.performance.now();
                const delta = window.performance.now() - state.updateData.lastUpdate;
                const updatesAmount = Math.floor(delta / state.updateData.tickDurationMs);
                state.updateData.lastUpdate += state.updateData.tickDurationMs * updatesAmount;

                for (let i = 0; i < updatesAmount; i++) {
                    if (state.levelData.isRunning) {
                        state.levelData.tubes.forEach((tube) => {
                            tube.update();
                        });
                        state.levelData.player.update();
                        if (config.debug) {
                            state.levelData.player.velocity = 0;
                            state.levelData.player.x =
                                (state.debug.x - state.debug.offsetX) / state.width;
                            state.levelData.player.y =
                                (state.debug.y - state.debug.offsetY) / state.height;
                        }

                        // if (state.input.down === true) state.player.y = state.player.y + 1;

                        if (
                            (state.updateData.ticks - state.levelData.startTick) %
                                (state.updateData.ticksPerSecond * 4) ===
                            0
                        ) {
                            state.levelData.tubes.push(
                                new Obstacle(1 + 50 / config.width / 2, Math.random())
                            );
                        }
                    }

                    state.updateData.ticks++;
                }
            }

            function end() {}

            function start() {
                // levelData: {
                //     tubes: [],
                //     player: new Player(),
                // },

                state.levelData = {
                    isRunning: true,
                    tubes: [],
                    player: new Player(),
                    startTick: state.updateData.ticks,
                };

                console.log('start');
            }

            function run() {
                start();
                const cycle = () => {
                    update();
                    render();
                    window.requestAnimationFrame(cycle);
                };
                cycle();
            }

            setScale();
            run();

            window.addEventListener('resize', () => {
                setScale();
                render();
            });

            if (config.debug) {
                canvas.addEventListener('mousemove', (e) => {
                    state.debug.x = e.clientX;
                    state.debug.y = e.clientY;
                    console.log(e);
                });
            }

            window.addEventListener('keydown', (e) => {
                console.log(e);
                if (e.repeat) return;
                if (e.code === 'Space' && window.performance.now() > state.input.lastUpTime + 5) {
                    state.input.lastUpTime = window.performance.now();
                    state.input.up = true;
                }
            });

            window.addEventListener('keyup', (e) => {
                console.log(e);
                if (e.repeat) return;
                if (e.code === 'Space') {
                    state.input.up = false;
                }
            });
        </script>
    </body>
</html>
